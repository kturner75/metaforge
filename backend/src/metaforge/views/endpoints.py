"""View configuration API endpoints."""

from typing import Any, Callable

from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel

from metaforge.views.store import SavedConfigStore
from metaforge.views.loader import ViewConfigLoader
from metaforge.views.types import (
    ConfigScope,
    ConfigSource,
    DataPattern,
    OwnerType,
    SavedConfig,
)


class CreateConfigRequest(BaseModel):
    """Request body for creating a config."""

    name: str
    description: str | None = None
    entity_name: str | None = None
    pattern: str
    style: str
    scope: str = "personal"
    data_config: dict[str, Any]
    style_config: dict[str, Any]


class UpdateConfigRequest(BaseModel):
    """Request body for updating a config."""

    name: str | None = None
    description: str | None = None
    data_config: dict[str, Any] | None = None
    style_config: dict[str, Any] | None = None
    scope: str | None = None


def _get_user_context(request: Request) -> dict[str, str | None]:
    """Extract user context from request state."""
    user_context = getattr(request.state, "user_context", None)
    if user_context:
        return {
            "user_id": user_context.user_id,
            "tenant_id": user_context.tenant_id,
            "role": user_context.roles[0] if user_context.roles else None,
        }
    return {"user_id": None, "tenant_id": None, "role": None}


def create_views_router(
    get_config_store: Callable[[], SavedConfigStore | None],
    get_view_loader: Callable[[], ViewConfigLoader | None],
) -> APIRouter:
    """Create the views router with injected dependencies."""
    router = APIRouter(prefix="/api/views", tags=["views"])

    @router.get("/configs")
    async def list_configs(
        entity_name: str | None = None,
        pattern: str | None = None,
        style: str | None = None,
    ) -> dict[str, Any]:
        """List saved configs with optional filters."""
        store = get_config_store()
        if not store:
            raise HTTPException(500, "Service not initialized")

        configs = store.list(
            entity_name=entity_name,
            pattern=pattern,
            style=style,
        )
        return {"data": [c.to_dict() for c in configs]}

    @router.get("/resolve")
    async def resolve_config(
        entity_name: str,
        style: str,
        http_request: Request,
    ) -> dict[str, Any]:
        """Resolve a config using precedence: user > role > tenant > global."""
        store = get_config_store()
        if not store:
            raise HTTPException(500, "Service not initialized")

        ctx = _get_user_context(http_request)
        config = store.resolve(
            entity_name=entity_name,
            style=style,
            user_id=ctx["user_id"],
            role=ctx["role"],
            tenant_id=ctx["tenant_id"],
        )
        if not config:
            raise HTTPException(404, f"No config found for {entity_name}/{style}")

        return {"data": config.to_dict()}

    @router.get("/configs/{config_id}")
    async def get_config(config_id: str) -> dict[str, Any]:
        """Get a single config by ID."""
        store = get_config_store()
        loader = get_view_loader()
        if not store:
            raise HTTPException(500, "Service not initialized")

        # Check DB first
        config = store.get(config_id)
        if not config and loader:
            # Fall back to YAML loader
            config = loader.get_config(config_id)
        if not config:
            raise HTTPException(404, "Config not found")

        return {"data": config.to_dict()}

    @router.post("/configs", status_code=201)
    async def create_config(
        request: CreateConfigRequest,
        http_request: Request,
    ) -> dict[str, Any]:
        """Create a new config."""
        store = get_config_store()
        if not store:
            raise HTTPException(500, "Service not initialized")

        ctx = _get_user_context(http_request)

        # Determine owner based on scope
        scope = ConfigScope(request.scope)
        if scope == ConfigScope.PERSONAL:
            owner_type = OwnerType.USER
            owner_id = ctx["user_id"]
        elif scope == ConfigScope.ROLE:
            owner_type = OwnerType.ROLE
            owner_id = ctx["role"]
        else:
            owner_type = OwnerType.GLOBAL
            owner_id = None

        config = SavedConfig(
            id="",  # Generated by store
            name=request.name,
            description=request.description,
            entity_name=request.entity_name,
            pattern=DataPattern(request.pattern),
            style=request.style,
            owner_type=owner_type,
            owner_id=owner_id,
            tenant_id=ctx["tenant_id"],
            scope=scope,
            data_config=request.data_config,
            style_config=request.style_config,
            source=ConfigSource.DATABASE,
            created_by=ctx["user_id"],
            updated_by=ctx["user_id"],
        )
        created = store.create(config)
        return {"data": created.to_dict()}

    @router.put("/configs/{config_id}")
    async def update_config(
        config_id: str,
        request: UpdateConfigRequest,
        http_request: Request,
    ) -> dict[str, Any]:
        """Update an existing config."""
        store = get_config_store()
        if not store:
            raise HTTPException(500, "Service not initialized")

        existing = store.get(config_id)
        if not existing:
            raise HTTPException(404, "Config not found")

        if existing.source == ConfigSource.YAML:
            raise HTTPException(403, "Cannot edit YAML-source configs")

        updates: dict[str, Any] = {}
        if request.name is not None:
            updates["name"] = request.name
        if request.description is not None:
            updates["description"] = request.description
        if request.data_config is not None:
            updates["data_config"] = request.data_config
        if request.style_config is not None:
            updates["style_config"] = request.style_config
        if request.scope is not None:
            updates["scope"] = request.scope

        ctx = _get_user_context(http_request)
        updates["updated_by"] = ctx["user_id"]

        updated = store.update(config_id, updates)
        if not updated:
            raise HTTPException(500, "Update failed")

        return {"data": updated.to_dict()}

    @router.delete("/configs/{config_id}")
    async def delete_config(
        config_id: str,
    ) -> dict[str, bool]:
        """Delete a config."""
        store = get_config_store()
        if not store:
            raise HTTPException(500, "Service not initialized")

        existing = store.get(config_id)
        if not existing:
            raise HTTPException(404, "Config not found")

        if existing.source == ConfigSource.YAML:
            raise HTTPException(403, "Cannot delete YAML-source configs")

        deleted = store.delete(config_id)
        return {"success": deleted}

    return router
